<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Paint Bucket Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        /* Custom transparency checkerboard pattern */
        .canvas-bg {
            background-image: 
                linear-gradient(45deg, #e5e7eb 25%, transparent 25%), 
                linear-gradient(-45deg, #e5e7eb 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #e5e7eb 75%), 
                linear-gradient(-45deg, transparent 75%, #e5e7eb 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            background-color: #ffffff;
        }

        /* Range slider styling */
        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
        }
        
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            margin-top: -6px; 
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #e5e7eb;
            border-radius: 2px;
        }

        .tool-btn.active {
            background-color: #eff6ff;
            border-color: #3b82f6;
            color: #1d4ed8;
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 h-screen flex flex-col overflow-hidden font-sans">

    <!-- Header -->
    <header class="bg-white border-b border-gray-200 px-6 py-3 flex justify-between items-center shadow-sm z-10 shrink-0">
        <div class="flex items-center gap-3">
            <div class="w-8 h-8 bg-blue-600 rounded-lg flex items-center justify-center text-white">
                <i class="fas fa-fill-drip"></i>
            </div>
            <h1 class="font-bold text-lg text-gray-800">SmartFill<span class="text-blue-600">Pro</span></h1>
        </div>
        
        <div class="flex gap-3">
            <button onclick="document.getElementById('fileInput').click()" class="bg-gray-100 hover:bg-gray-200 text-gray-700 px-4 py-2 rounded-lg text-sm font-medium transition flex items-center gap-2">
                <i class="fas fa-folder-open"></i> Open Image
            </button>
            <button onclick="downloadImage()" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition shadow flex items-center gap-2">
                <i class="fas fa-download"></i> Download
            </button>
            <input type="file" id="fileInput" accept="image/png, image/jpeg, image/webp" class="hidden">
        </div>
    </header>

    <!-- Main Workspace -->
    <div class="flex flex-1 overflow-hidden relative">
        
        <!-- Left Sidebar: Controls -->
        <aside class="w-80 bg-white border-r border-gray-200 flex flex-col overflow-y-auto shrink-0 z-10 p-5 gap-6 shadow-sm">
            
            <!-- Mode Selection -->
            <div>
                <label class="text-xs font-bold text-gray-400 uppercase tracking-wider mb-3 block">Fill Mode</label>
                <div class="flex gap-2">
                    <button id="modeColor" onclick="setMode('color')" class="tool-btn active flex-1 border border-gray-200 rounded-lg p-3 flex flex-col items-center gap-2 hover:bg-gray-50 transition">
                        <div class="w-6 h-6 rounded-full border border-gray-300" id="colorPreview" style="background-color: #3b82f6;"></div>
                        <span class="text-xs font-medium">Color Fill</span>
                    </button>
                    <button id="modeErase" onclick="setMode('erase')" class="tool-btn flex-1 border border-gray-200 rounded-lg p-3 flex flex-col items-center gap-2 hover:bg-gray-50 transition">
                        <div class="w-6 h-6 rounded-full border border-gray-300 canvas-bg"></div>
                        <span class="text-xs font-medium">Erase</span>
                    </button>
                </div>
            </div>

            <!-- Color Picker -->
            <div id="colorPickerContainer">
                <label class="text-xs font-bold text-gray-400 uppercase tracking-wider mb-2 block">Fill Color</label>
                <div class="flex items-center gap-3">
                    <input type="color" id="colorInput" value="#3b82f6" class="w-10 h-10 p-0 border-0 rounded cursor-pointer overflow-hidden shadow-sm">
                    <span id="colorHex" class="text-sm font-mono text-gray-500 uppercase">#3B82F6</span>
                </div>
            </div>

            <!-- Sliders -->
            <div class="space-y-5">
                <!-- Tolerance -->
                <div>
                    <div class="flex justify-between mb-1">
                        <label class="text-xs font-bold text-gray-500">Tolerance</label>
                        <span id="toleranceVal" class="text-xs font-medium bg-gray-100 px-2 py-0.5 rounded text-gray-600">15%</span>
                    </div>
                    <input type="range" id="tolerance" min="0" max="255" value="40" class="w-full">
                    <p class="text-[10px] text-gray-400 mt-1">Higher values fill more diverse colors.</p>
                </div>

                <!-- Opacity -->
                <div>
                    <div class="flex justify-between mb-1">
                        <label class="text-xs font-bold text-gray-500">Opacity</label>
                        <span id="opacityVal" class="text-xs font-medium bg-gray-100 px-2 py-0.5 rounded text-gray-600">100%</span>
                    </div>
                    <input type="range" id="opacity" min="0" max="100" value="100" class="w-full">
                </div>

                 <!-- Softness/Feather -->
                 <div>
                    <div class="flex justify-between mb-1">
                        <label class="text-xs font-bold text-gray-500">Edge Bleed</label>
                        <span id="bleedVal" class="text-xs font-medium bg-gray-100 px-2 py-0.5 rounded text-gray-600">0px</span>
                    </div>
                    <input type="range" id="bleed" min="0" max="5" value="0" class="w-full">
                    <p class="text-[10px] text-gray-400 mt-1">Expands fill slightly to cover edges.</p>
                </div>
            </div>

            <!-- Undo/Redo -->
            <div class="mt-auto border-t border-gray-100 pt-5">
                <div class="grid grid-cols-2 gap-3">
                    <button onclick="undo()" id="undoBtn" disabled class="disabled:opacity-40 disabled:cursor-not-allowed bg-white border border-gray-200 hover:bg-gray-50 text-gray-700 py-2 rounded-lg text-sm font-medium transition">
                        <i class="fas fa-undo mr-1"></i> Undo
                    </button>
                    <button onclick="resetCanvas()" class="bg-white border border-gray-200 hover:text-red-600 hover:bg-red-50 text-gray-700 py-2 rounded-lg text-sm font-medium transition">
                        <i class="fas fa-trash-alt mr-1"></i> Reset
                    </button>
                </div>
            </div>
        </aside>

        <!-- Canvas Area -->
        <main class="flex-1 bg-gray-100 overflow-auto relative flex items-center justify-center p-8 cursor-crosshair" id="canvasContainer">
            <!-- Initial Empty State -->
            <div id="emptyState" class="text-center p-10 bg-white rounded-2xl shadow-sm border border-gray-200 max-w-md">
                <div class="w-16 h-16 bg-blue-50 text-blue-500 rounded-full flex items-center justify-center mx-auto mb-4 text-2xl">
                    <i class="fas fa-image"></i>
                </div>
                <h3 class="text-lg font-bold text-gray-800 mb-2">Upload an Image to Start</h3>
                <p class="text-gray-500 text-sm mb-6">Supports PNG, JPG, WebP. Images are processed locally in your browser.</p>
                <button onclick="document.getElementById('fileInput').click()" class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-2.5 rounded-xl font-medium shadow-md transition transform active:scale-95">
                    Select Image
                </button>
            </div>

            <!-- Canvas Wrapper (Hidden initially) -->
            <div id="canvasWrapper" class="hidden shadow-2xl rounded-sm overflow-hidden border border-gray-300 bg-white">
                <canvas id="editorCanvas" class="canvas-bg block"></canvas>
            </div>
        </main>
    </div>

    <!-- Notification Toast -->
    <div id="toast" class="fixed bottom-5 right-5 bg-gray-800 text-white px-4 py-3 rounded-lg shadow-lg transform translate-y-20 transition-transform duration-300 flex items-center gap-3 z-50">
        <i class="fas fa-info-circle text-blue-400"></i>
        <span id="toastMsg" class="text-sm font-medium">Notification</span>
    </div>

    <script>
        // -- App State --
        const canvas = document.getElementById('editorCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const historyStack = [];
        let currentMode = 'color'; // 'color' or 'erase'
        let isProcessing = false;

        // -- DOM Elements --
        const fileInput = document.getElementById('fileInput');
        const emptyState = document.getElementById('emptyState');
        const canvasWrapper = document.getElementById('canvasWrapper');
        const colorInput = document.getElementById('colorInput');
        const toleranceInput = document.getElementById('tolerance');
        const opacityInput = document.getElementById('opacity');
        const bleedInput = document.getElementById('bleed');
        const undoBtn = document.getElementById('undoBtn');

        // -- Initialization --
        
        fileInput.addEventListener('change', handleFileUpload);
        
        // Input Listeners for UI Updates
        colorInput.addEventListener('input', (e) => {
            document.getElementById('colorPreview').style.backgroundColor = e.target.value;
            document.getElementById('colorHex').textContent = e.target.value;
        });

        toleranceInput.addEventListener('input', (e) => {
            document.getElementById('toleranceVal').textContent = Math.round((e.target.value / 255) * 100) + "%";
        });

        opacityInput.addEventListener('input', (e) => {
            document.getElementById('opacityVal').textContent = e.target.value + "%";
        });

        bleedInput.addEventListener('input', (e) => {
            document.getElementById('bleedVal').textContent = e.target.value + "px";
        });

        canvas.addEventListener('mousedown', onCanvasClick);

        // -- Core Functions --

        function setMode(mode) {
            currentMode = mode;
            document.getElementById('modeColor').classList.toggle('active', mode === 'color');
            document.getElementById('modeErase').classList.toggle('active', mode === 'erase');
            
            // Toggle opacity/color visibility
            const colorContainer = document.getElementById('colorPickerContainer');
            if (mode === 'erase') {
                colorContainer.classList.add('opacity-50', 'pointer-events-none');
            } else {
                colorContainer.classList.remove('opacity-50', 'pointer-events-none');
            }
        }

        function handleFileUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    // Reset history
                    historyStack.length = 0;
                    updateUndoState();
                    
                    // Size canvas
                    canvas.width = img.width;
                    canvas.height = img.height;
                    
                    // Draw image
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);

                    // Show canvas, hide empty state
                    emptyState.classList.add('hidden');
                    canvasWrapper.classList.remove('hidden');
                    
                    // Fit view
                    // This is handled by CSS flex layout automatically mostly, 
                    // but we ensure the container centers it.
                    showToast("Image loaded successfully");
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }

        function hexToRgba(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return { r, g, b, a: 255 };
        }

        function saveState() {
            if (historyStack.length >= 10) historyStack.shift(); // Limit history
            historyStack.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
            updateUndoState();
        }

        function undo() {
            if (historyStack.length === 0) return;
            const previousState = historyStack.pop();
            ctx.putImageData(previousState, 0, 0);
            updateUndoState();
            showToast("Undo action");
        }

        function updateUndoState() {
            undoBtn.disabled = historyStack.length === 0;
        }

        function resetCanvas() {
            // Reload the file if it exists, or clear
            if (confirm("Reset all changes?")) {
                if(fileInput.files[0]) {
                    handleFileUpload({target: fileInput});
                } else {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    historyStack.length = 0;
                    updateUndoState();
                }
            }
        }

        function downloadImage() {
            if (canvasWrapper.classList.contains('hidden')) {
                showToast("Please upload an image first");
                return;
            }
            const link = document.createElement('a');
            link.download = 'edited-image.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        function showToast(msg) {
            const toast = document.getElementById('toast');
            document.getElementById('toastMsg').textContent = msg;
            toast.classList.remove('translate-y-20');
            setTimeout(() => {
                toast.classList.add('translate-y-20');
            }, 3000);
        }

        // -- The Flood Fill Algorithm --

        function onCanvasClick(e) {
            if (isProcessing) return;
            
            // Get coordinates
            const rect = canvas.getBoundingClientRect();
            
            // Scale logic for high-DPI or CSS resized canvas
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const x = Math.floor((e.clientX - rect.left) * scaleX);
            const y = Math.floor((e.clientY - rect.top) * scaleY);

            // Save state before modifying
            saveState();

            // Prepare Parameters
            const tolerance = parseInt(toleranceInput.value);
            const opacity = parseInt(opacityInput.value) / 100;
            const bleed = parseInt(bleedInput.value);
            
            let fillColor;
            if (currentMode === 'erase') {
                fillColor = { r:0, g:0, b:0, a:0 }; // Alpha 0 for erase
            } else {
                fillColor = hexToRgba(colorInput.value);
                fillColor.a = Math.floor(255 * opacity);
            }

            // Perform Fill (Async to not freeze UI immediately)
            isProcessing = true;
            canvas.style.cursor = 'wait';
            
            requestAnimationFrame(() => {
                floodFill(x, y, fillColor, tolerance, currentMode === 'erase', bleed);
                isProcessing = false;
                canvas.style.cursor = 'crosshair';
            });
        }

        function floodFill(startX, startY, fillColor, tolerance, isErase, bleed) {
            const w = canvas.width;
            const h = canvas.height;
            const imageData = ctx.getImageData(0, 0, w, h);
            const data = imageData.data; // Uint8ClampedArray

            // Get target color at start position
            const startPos = (startY * w + startX) * 4;
            const targetColor = {
                r: data[startPos],
                g: data[startPos + 1],
                b: data[startPos + 2],
                a: data[startPos + 3]
            };

            // Optimization: If filling same color, return
            if (!isErase && 
                targetColor.r === fillColor.r && 
                targetColor.g === fillColor.g && 
                targetColor.b === fillColor.b && 
                targetColor.a === fillColor.a) {
                return;
            }

            const visited = new Uint8Array(w * h); // 0 = unvisited, 1 = visited
            const queue = [[startX, startY]];
            
            // Pixels to be modified. Stored as indices to avoid recalculating.
            const pixelsToFill = [];

            // Helper to check color match
            function match(pos) {
                const r = data[pos];
                const g = data[pos + 1];
                const b = data[pos + 2];
                const a = data[pos + 3];

                // Simple Euclidean distance approximation or Sum of Diff
                // Sum of absolute differences is faster
                const diff = Math.abs(r - targetColor.r) +
                             Math.abs(g - targetColor.g) +
                             Math.abs(b - targetColor.b) +
                             Math.abs(a - targetColor.a);
                
                return diff <= tolerance;
            }

            // 1. BFS to find all connected pixels
            while (queue.length > 0) {
                const [cx, cy] = queue.shift();
                const idx = cy * w + cx;
                
                if (visited[idx]) continue;
                
                const pos = idx * 4;
                if (!match(pos)) continue;

                // Mark visited
                visited[idx] = 1;
                pixelsToFill.push(idx);

                // Add neighbors
                if (cx > 0) queue.push([cx - 1, cy]);
                if (cx < w - 1) queue.push([cx + 1, cy]);
                if (cy > 0) queue.push([cx, cy - 1]);
                if (cy < h - 1) queue.push([cx, cy + 1]);
            }

            // 2. Handle Bleed/Expansion (Simple morphological dilation)
            // If bleed > 0, we add neighbors of the found pixels to the list
            if (bleed > 0) {
                // We need a temp set to avoid duplicates or adding already visited
                // Using an array of passes for the bleed amount
                let currentBoundary = [...pixelsToFill];
                
                for(let b = 0; b < bleed; b++) {
                    const nextBoundary = [];
                    for(let i = 0; i < currentBoundary.length; i++) {
                        const idx = currentBoundary[i];
                        const bx = idx % w;
                        const by = Math.floor(idx / w);
                        
                        // Check 4 neighbors
                        const neighbors = [
                            [bx - 1, by], [bx + 1, by], 
                            [bx, by - 1], [bx, by + 1]
                        ];

                        for(let n of neighbors) {
                            const nx = n[0];
                            const ny = n[1];
                            if(nx >= 0 && nx < w && ny >= 0 && ny < h) {
                                const nIdx = ny * w + nx;
                                if(visited[nIdx] === 0) {
                                    visited[nIdx] = 1; // Mark as part of the fill now
                                    pixelsToFill.push(nIdx);
                                    nextBoundary.push(nIdx);
                                }
                            }
                        }
                    }
                    currentBoundary = nextBoundary;
                }
            }

            // 3. Apply Colors
            for (let i = 0; i < pixelsToFill.length; i++) {
                const idx = pixelsToFill[i] * 4;

                if (isErase) {
                    // Erase to transparent
                    data[idx + 3] = 0; 
                } else {
                    // Blend Colors
                    // New Color = Fill * Alpha + Old * (1 - Alpha)
                    const alpha = fillColor.a / 255;
                    const invAlpha = 1 - alpha;
                    
                    // If opacity is 100%, just overwrite (faster)
                    if (alpha === 1) {
                        data[idx] = fillColor.r;
                        data[idx + 1] = fillColor.g;
                        data[idx + 2] = fillColor.b;
                        data[idx + 3] = 255; // Fully opaque result
                    } else {
                        // Standard blending
                        data[idx] = Math.round(fillColor.r * alpha + data[idx] * invAlpha);
                        data[idx + 1] = Math.round(fillColor.g * alpha + data[idx + 1] * invAlpha);
                        data[idx + 2] = Math.round(fillColor.b * alpha + data[idx + 2] * invAlpha);
                        // Alpha accumulation is complex, simplistically we max it out or blend
                        data[idx + 3] = Math.min(255, data[idx + 3] + fillColor.a);
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }
    </script>
</body>
</html>